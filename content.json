[{"title":"Collectin第一篇-ArrayList源码浅析","date":"2017-01-08T04:50:58.000Z","path":"2017/01/08/Collection1/","text":"Collection第一篇 ArrayList源码浅析每天写业务逻辑.代码量其实不少.不过真正总结起来,发现自己基础真心不扎实. 工作是越来越顺手,但技术还一直停留在上学时的水平. 静下来想想,自己会的东西真不多.以后会争取多整理各种常用工具类和常用框架的源码文档,在这里分享. 作为一枚Java猿,不管是在学校学习还是在公司工作,最常用的类一定是String以及Collection中的ArrayList和HashMap.这三个常用类里面,ArrayList的实现最为简单.所以先分享下自己总结的ArrayList实现方式. 下面直接上代码和注释:发现JDK版本不同,源码的设计有些差异.公司环境为JDK1.6,我的电脑环境是JDK1.7.因为在公司时间比较久,主要总结实现方式和代码逻辑.所以用1.6版本为例,两个版本差别不大.(个人觉得还是1.7版本的代码更好看) 1234567891011121314151617181920212223下面三个变量是ArrayList的全局变量.JDK1.7版本多出来一个,下面会有说明. /** * ArrayList是List的实现类,List是序列化了的.所以ArrayList也是序列化的类. * 关于Collection每个类和接口的关系以后写.这里不需要关心. * serialVersionUID就是序列化的版本号,以后写到序列化的时候再说.同样不需要关心. */ private static final long serialVersionUID = 8683452581122892189L; /** * ArrayList是基于数组实现的. elementData当然就是存放元素的数组咯. * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. */ private transient Object[] elementData; /** * 数组容量的大小. * The size of the ArrayList (the number of elements it contains). * @serial */ private int size; ArrayList共有三个构造方法,如下: ArrayList()：默认构造函数，提供初始容量为 10 的空列表。 ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表。 ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 12345678910默认无参数构造方法最常用的构造方法.new ArrayList()时,会调用下面带参数的构造方法1-&gt;public ArrayList(int initialCapacity)ArrayList初始数组容量为10. /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this(10); &#125; 12345678910111213141516171819带参数的构造方法1调用时传入int参数initialCapacity,指定初始ArrayList的大小.如果initialCapacity为负值,抛IllegalArgumentException异常.(TODO 关于异常栈的总结,以后找时间push上来) /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @exception IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); this.elementData = new Object[initialCapacity]; &#125; 1234567891011121314151617带参数的构造方法2构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列 /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&apos;s * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; ArrayList的扩容方法. ArrayList本身就是一个可变长度的数组,扩容方法可以说是核心的实现.其实就是个数组的复制过程.大一教材的内容,并不难.面试总会被问,ArrayList是怎么扩容的.就是这个东西~ 这里对方法中的modCount变量做一下特殊说明: modCount继承自AbstractList抽象类. 这个方法需要特别注意的是 modCount++这个操作,作用是用来记录对ArrayList的每一次操作,也就是说你对ArrayList的每一次操作它都会进行++,不管是add、remove等等.我们知道在对集合进行迭代的时候,不能对集合进行remove的操作,它就是通过对比这个值来判断的. 12345678910111213141516171819/** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ public void ensureCapacity(int minCapacity) &#123; modCount++;//方法中的modCount继承自AbstractList抽象类. int oldCapacity = elementData.length;//记录elementData数组的长度,也就是当前ArrayList的容量 if (minCapacity &gt; oldCapacity) &#123;// 如果传入参数minCapacity大于当前容量 Object oldData[] = elementData;// 保存当前ArrayList元素 int newCapacity = (oldCapacity * 3)/2 + 1;//用当前容量*3/2+1 计算出扩容后ArrayList的大小 经常有人说ArrayList每次扩容的大小是原来的1.5倍,就是这么来的 但并不完全正确.原因,往下看~ if (newCapacity &lt; minCapacity) // 计算出的新容量和传入参数容量的大小 两个值中较大值 newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);// 调用copy方法,扩容数组 &#125; &#125; 12345678910111213trimToSize():将此 ArrayList 实例的容量调整为列表的当前大小。/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list&apos;s current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */ public void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; //记录当前实际容量大小 if (size &lt; oldCapacity) &#123;// 判断当前实际容量与列表容量的大小,取较小值 elementData = Arrays.copyOf(elementData, size); // 按容量最小值复制数组 &#125; &#125; 123456789返回当前列表中的元素数。 /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size() &#123; return size; &#125; 123456789判断当前ArrayList是否为空. /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements. * * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements */ public boolean isEmpty() &#123; return size == 0; &#125; contains()方法调用indexof()方法,通过其返回值判断ArrayList中是否包含传入的对象.主要是indexof()方法的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253判断当前列表中是否包含传入对象. /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains * at least one element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this list is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125;返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。 /** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int indexOf(Object o) &#123; if (o == null) &#123; // 如果入参为null for (int i = 0; i &lt; size; i++) // 遍历数组 if (elementData[i]==null) // 找到value为null的索引i return i; // 返回索引 &#125; else &#123; // 如果入参不为null for (int i = 0; i &lt; size; i++) // 遍历数组 if (o.equals(elementData[i])) // 找到value为o的索引i return i; // 返回索引 &#125; return -1; // 入参对象在列表中不存在, 返回-1 &#125;返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。 /** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; // 如果入参为null for (int i = size-1; i &gt;= 0; i--) // 倒序遍历数组 if (elementData[i]==null) // 找到value为null的索引i return i; // 返回索引 &#125; else &#123; // 如果入参不为null for (int i = size-1; i &gt;= 0; i--) // 倒序遍历数组 if (o.equals(elementData[i])) // 找到value为o的索引i return i; // 返回索引 &#125; return -1; // 入参对象在列表中不存在, 返回-1 &#125; 123456789101112131415161718返回此 ArrayList 实例的浅表副本。 /** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */ public Object clone() &#123; try &#123; ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。 /** * Returns an array containing all of the elements in this list * in proper sequence (from first to last element). * * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are * maintained by this list. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this list in * proper sequence */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * Returns an array containing all of the elements in this list in proper * sequence (from first to last element); the runtime type of the returned * array is that of the specified array. If the list fits in the * specified array, it is returned therein. Otherwise, a new array is * allocated with the runtime type of the specified array and the size of * this list. * * &lt;p&gt;If the list fits in the specified array with room to spare * (i.e., the array has more elements than the list), the element in * the array immediately following the end of the collection is set to * &lt;tt&gt;null&lt;/tt&gt;. (This is useful in determining the length of the * list &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain * any null elements.) * * @param a the array into which the elements of the list are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose. * @return an array containing the elements of the list * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this list * @throws NullPointerException if the specified array is null */ public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a&apos;s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; 123456789101112131415获取当前列表中索引为i的元素. // Positional Access Operations /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; RangeCheck(index); // 校验index是否越界,具体实现方法在下面. return (E) elementData[index]; // 返回索引为i的元素 &#125; 1234567891011121314151617替换当前列表中指定位置元素 /** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E set(int index, E element) &#123; RangeCheck(index); // 校验index是否越界,具体实现方法在下面. E oldValue = (E) elementData[index]; // 保存被替换的元素 elementData[index] = element; // 替换当前位置元素 return oldValue; // 返回被替换的元素 &#125; 向列表中添加元素的方法 1234567891011121314151617181920212223242526272829303132333435add方法1:想当前列表尾插入元素 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; // 调用扩容方法,注意: 这里没有modCount变量!! ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; // 把元素插入到当前列表最后端 return true; // 返回插入成功 &#125; add方法2:向当前列表指定位置插入元素 /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) // 判断index是否合法 throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+&quot;, Size: &quot;+size); // 调用扩容方法,注意: 这里没有modCount变量!! ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); // index到列表的元素一次向后移动一个位置 elementData[index] = element; // 把元素插入到index位置 size++; // 列表容量+1 &#125; 删除方法的实现. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384remove方法1,删除列表中指定索引的元素. /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; RangeCheck(index); // 校验index是否合法 modCount++; E oldValue = (E) elementData[index]; // 保存被删除的元素 int numMoved = size - index - 1; // 计算index到列表末尾共有多少元素 if (numMoved &gt; 0) // numMoved合法,把index开始到列表末尾的所有元素一次向前移动一个位置 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后空出的位置置为空,gc启动时自动回收. elementData[--size] = null; // Let gc do its work return oldValue; //返回被删除的元素 &#125; remove方法2:根据指定元素删除. /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; // 如果元素为null for (int index = 0; index &lt; size; index++) // 遍历当前列表 if (elementData[index] == null) &#123; // 找到null元素的索引 fastRemove(index); // 删除该元素 return true; // 返回成功 &#125; &#125; else &#123; // 如果元素不为null for (int index = 0; index &lt; size; index++) // 遍历当前列表 if (o.equals(elementData[index])) &#123; // 找到当前元素的索引 fastRemove(index); // 删除该元素 return true; // 返回成功 &#125; &#125; return false; // 返回失败 &#125;fastRemove在上面remove方法中被调用. /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work &#125;clear方法,删除列表中所有元素. /** * Removes all of the elements from this list. The list will * be empty after this call returns. */ public void clear() &#123; modCount++; // Let gc do its work for (int i = 0; i &lt; size; i++) // 遍历当前列表 elementData[i] = null; // 将元素置为空 size = 0; // 返回列表长度 &#125; 添加Collection中所有元素到当前列表. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758addAll方法1: 将Collection添加到当前列表尾部 /** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection&apos;s Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); // 将Collection转成数组 int numNew = a.length; // 保存数组长度 ensureCapacity(size + numNew); // Increments modCount // 调用扩容方法 System.arraycopy(a, 0, elementData, size, numNew); // 复制数组到当前列表中 size += numNew; // 改变后数组的长度 return numNew != 0; // 返回 &#125; addAll方法2:向指定位置添加Collection /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection&apos;s iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) // 判断index是否合法 throw new IndexOutOfBoundsException( &quot;Index: &quot; + index + &quot;, Size: &quot; + size); Object[] a = c.toArray(); // 把Collection转换成数组 int numNew = a.length; // 保存数组长度 ensureCapacity(size + numNew); // Increments modCount // 调用扩容方法 int numMoved = size - index; // 计算index到最后剩余元素(需要移动元素)的个数 if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将Object[] a从index位置开始插入 System.arraycopy(a, 0, elementData, index, numNew); // 插入到末尾 size += numNew; // 改变列表长度 return numNew != 0; //返回 &#125; 需要注意,removeRange方法是protected类型的. 12345678910111213141516171819202122232425删除指定范围内的元素. /** * Removes from this list all of the elements whose index is between * &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, and &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive. * Shifts any succeeding elements to the left (reduces their index). * This call shortens the list by &lt;tt&gt;(toIndex - fromIndex)&lt;/tt&gt; elements. * (If &lt;tt&gt;toIndex==fromIndex&lt;/tt&gt;, this operation has no effect.) * * @param fromIndex index of first element to be removed * @param toIndex index after last element to be removed * @throws IndexOutOfBoundsException if fromIndex or toIndex out of * range (fromIndex &amp;lt; 0 || fromIndex &amp;gt;= size() || toIndex * &amp;gt; size() || toIndex &amp;lt; fromIndex) */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; // 计算需要移动元素的个数 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // 移动元素,将fromIndex至toIndex范围内的元素覆盖 // Let gc do its work int newSize = size - (toIndex-fromIndex); //计算新的列表长度 while (size != newSize) // 如果新的长度与原长度不相等, elementData[--size] = null; // 多出来的位置设置为null gc启动时自动回收 &#125; 123456789101112校验index是否在合法范围. /** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */ private void RangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+&quot;, Size: &quot;+size); &#125; 下面关于序列化等问题的方法以后再说. 1234567891011121314151617181920212223242526272829303132333435363738394041424344 /** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123;// Write out element count, and any hidden stuffint expectedModCount = modCount;s.defaultWriteObject(); // Write out array length s.writeInt(elementData.length);// Write out all elements in the proper order.for (int i=0; i&lt;size; i++) s.writeObject(elementData[i]);if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123;// Read in size, and any hidden stuffs.defaultReadObject(); // Read in array length and allocate array int arrayLength = s.readInt(); Object[] a = elementData = new Object[arrayLength];// Read in all elements in the proper order.for (int i=0; i&lt;size; i++) a[i] = s.readObject(); &#125; 后记2017给自己的承诺已经开始兑现.这是第一篇源码浅析,还有很多细节没有写清楚.比如removeRange方法为什么会设置成Procted.最后的两个方法也没有写注释.以后都会慢慢补上. Collection的源码自己看过一些,但是总结起来发现之前还是漏掉了许多细节.争取以后慢慢都补上来. 计划是先写浅析,把常用类,常用方法具体如何实现先写清楚.然后再深入每一个细节,最后再把Collection整个继承和实现类图画出来总结一下. 工作之余完成这些东西时间确实很紧,可能也会有理解不到位出现错误的地方.随着以后理解的深入,再回来更正.这是一个漫长的过程~~~~ 这只是记录的一部分,以后争取穿插着记录一些Redis,设计模式,实际问题和解决方案. 最后是一道思考题: ```程序输出是true还是false? 为什么??我也没太仔细研究….这个需要看一下equals方法是如何重写的. List list = new ArrayList(); list.add(“a”); // 使用构造器创建一个包含list的列表list1 List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(list); // 使用subList生成与list相同的列表list2 List&lt;String&gt; list2 = list.subList(0, list.size()); list2.add(&quot;b&quot;); System.out.println(list.equals(list1)); System.out.println(list.equals(list2)); ```-","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"送给2017","date":"2016-12-31T16:19:25.000Z","path":"2017/01/01/20170101hello/","text":"把石头还给石头.2016真是过的浮躁. 前半年是毕业设计. 后半年是业务逻辑. 总结下来,专业能力没什么进步,也没能像以前一样静下来好好读几本书. 2017,要静下来总结每一个知识点. 记录工作中每一个问题的解决方案. 依旧要坚持每天睡觉前,看三十分钟书.(2016一整年,貌似只读了一本口水书,一本散文,一本武侠,还有半本诗集.真是惭愧) 2017,把下面的城市列在旅行计划里: 南京 郑州 成都 德令哈 2016, 看时光白白流淌. 2017, 把石头还给石头.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"纪念2016","date":"2016-12-31T15:52:46.000Z","path":"2016/12/31/20161231zj/","text":"总是盼望太多,最后如不如意,都被时间浇熄. 2016就这样吧.你好,2017~","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"学习笔记","date":"2016-12-28T15:26:27.000Z","path":"2016/12/28/20161228xxbj/","text":"以后关于一些框架源码,数据结构,网络,等基础知识的学习,都在这里记录.","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"处女贴~~","date":"2016-12-28T14:49:04.000Z","path":"2016/12/28/20161228/","text":"今天是搭好博客的第一天,发个帖子纪念一下.总有一些苦,要学会自己受. 要是有一天受不了了,那就找个盼头,然后让自己受得了.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]