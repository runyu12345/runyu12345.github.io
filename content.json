[{"title":"写给自己","date":"2017-03-15T14:42:41.000Z","path":"2017/03/15/forMyself20170315/","text":"人生,很多事儿急不得,你得等它自己熟. 这一段时间以来,也接触了一些人,看了些代码.我想,一个人有多少天分,和在工作中能写出什么样的代码,可能并无太大关联. 当然,天分我还是有的,,我有能耐得住性子的天分. 人不能孤独的活着,孤独的人是可耻的. 之所以读书,做记录,有作品,是为了沟通,当然,写代码也是为了沟通,为了和机器沟通,和同行沟通.透过代码去告诉人家,心里的想法,世界的样子,所在意的,所珍惜的. 所以,作品和代码就是自己. 所有精工制作的物件,最珍贵的,不能代替的,就只有一个字,&quot;人&quot;. 人有情怀,有信念,有态度.所以理所当然,就是要在各种变数可能之中,仍然做到最好. 写代码的人会有好多称呼:程序猿,程序媛,攻城狮......其实我更喜欢把自己当做一个手艺人,也希望能把自己变成一个匠人. 因为,就算世界再吵杂,匠人的内心,必须是绝对安静,安定的. 我知道,手艺人往往意味着固执,缓慢,少量,劳作.但是这些背后,所隐含的是专注,技艺,对完美的追求.所以我宁愿这样,也一直这样,也必须这样. 一辈子,总是还得让一些善意,执念,推着往前.我们因此能愿意去听从内心的安排.跟着自己的心走,真的是一件勇敢的事情. 专注做点东西至少,对得起光阴岁月.其他的,就留给时间去说吧.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Push","date":"2017-02-12T11:59:05.000Z","path":"2017/02/12/Push/","text":"最近几天不是很忙,在读.书中关于多线程的知识讲解的非常好,无奈的是没有实际应用场景做支撑,学到的知识还是不知道怎么用.刚好Push中涉及到的多线程处理,消息队列模型也都是盲点.本着多学习的态度,有了记一次Push的想法~ Push Mail是用来描述电子邮件系统，提供了一个“永远在线”的能力：新的电子邮件会在到达邮件传递代理（MDA，一般称为邮件服务器）时被主动发送（Push）到用户邮件代理（MUA，也被称为电子邮件客户端）。今天的大多数客户都是使用智能手机来进行Push Mail。(以上对Push Mail的解释摘自维基百科,打不开的请自行穿越火线) 给小米打一波广告小米Push开放平台提供了包括客户端与服务端在内的SDK支持. Push服务器端主要流程1234567891011graph TDA[读取文件中内容,插入到消息队列中]--&gt;B[启动多个线程处理消息队列中的数据]B--&gt;|ThreadOne|C1[读取消息队列中的数据]C1--&gt;C2[组装消息体]C2--&gt;C3[发送]B--&gt;|ThreadTwo|D1[读取消息队列中的数据]D1--&gt;D2[组装消息体]D2--&gt;D3[发送]B--&gt;|ThreadThree|E1[读取消息队列中的数据]E1--&gt;E2[组装消息体]E2--&gt;E3[发送] 知识点说明Java消息服务（Java Message Service，JMS） Java 消息服务（Java Message Service，JMS）应用程序接口是一个Java 平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。Java 消息服务的规范包括两种消息模式，点对点和发布者/订阅者。许多提供商支持这一通用框架因此，程序员可以在他们的分布式软件中实现面向消息的操作，这些操作将具有不同面向消息中间件产品的可移植性。Java 消息服务支持同步和异步的消息处理，在某些场景下，异步消息是必要的；在其他场景下，异步消息比同步消息操作更加便利。 JMS(Java消息服务)入门教程这篇博客用来学习基本知识(概念,用途,原理)还是非常不错的. 消息队列的概念 在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它(以上对消息队列的解释摘自维基百科,打不开的请自行穿越火线) 阻塞队列（BlockingQueue） 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 Java JDK中的阻塞队列 ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。 DelayQueue：一个使用优先级队列实现的无界阻塞队列。 SynchronousQueue：一个不存储元素的阻塞队列。 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 具体实现变量与常量1234567891011121314151617181920212223242526272829 /** * 读取文件时缓冲流的大小 */ private static final int DEFAULT_LEN = 1000;/** * 致命毒药，用于干掉处理数据的线程。 */public final Object POISON = new Object();/** * 阻塞队列(存放消息内容) * ArrayBlockingQueue维护的是一个定长的数组,初始化是必须指定数组的大小 */private BlockingQueue&lt;Object&gt; queue = new ArrayBlockingQueue&lt;Object&gt;(64);/** * errorHandler */private ErrorHandler errorHandler = ErrorHandler.PRINTER;/** * 用于终止读取线程，非强制终止。 */private volatile boolean running = false;/** * 数据读取线程 */private Thread fileReader;/** * 数据处理线程 */private Thread[] proccessors; 读取线程与分发线程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public BigFileProcessor(final InputStream file, final DataHandler handler) &#123; fileReader = new Thread(new Runnable() &#123; public void run() &#123; BufferedReader reader = null; try &#123; Charset charset = Charset.defaultCharset(); reader = new BufferedReader(new InputStreamReader(file,charset)); String line = null; ArrayList&lt;String&gt; cache = new ArrayList&lt;String&gt;(); while(running&amp;&amp;(line=reader.readLine())!=null)&#123; line = line.trim(); if(line != &quot;&quot; &amp;&amp; line != null)&#123; cache.add(line); &#125; if(cache.size() == DEFAULT_LEN)&#123; Object tmpCache = ((ArrayList&lt;String&gt;)cache).clone(); queue.put(tmpCache); cache.clear(); &#125; &#125; if(cache.size() &gt;0)&#123; Object tmpCache = ((ArrayList&lt;String&gt;)cache).clone(); queue.put(tmpCache); &#125; &#125; catch (Throwable t) &#123; errorHandler.doHandler(t); &#125; finally &#123; try &#123; queue.put(POISON); if(reader != null)&#123; reader.close(); reader = null; &#125; &#125; catch (Exception e) &#123; errorHandler.doHandler(e); &#125; &#125; &#125; &#125;,&quot;reader_thread&quot;); //默认创建的线程数，与CPU处理的内核数相同，楼主可以自行更改。 proccessors = new Thread[Runtime.getRuntime().availableProcessors()]; Runnable worker = new Runnable() &#123; public void run() &#123; //System.out.println(&quot;worker start:&quot; + Thread.currentThread().getName()); try &#123; for(;;)&#123; Object obj = queue.take(); if(obj==POISON)&#123; //System.out.println(&quot;worker end:&quot; + Thread.currentThread().getName()); queue.put(obj); break; &#125;else&#123; List&lt;String&gt; data =(List&lt;String&gt;)obj; handler.doHandler(data); &#125; &#125; &#125; catch (Throwable t) &#123; errorHandler.doHandler(t); &#125; &#125; &#125;; for(int i=0;i&lt;proccessors.length;i++)&#123; proccessors[i] = new Thread(worker,&quot;proccessor-thread_&quot;+i); &#125; &#125; public void setErrorHandler(ErrorHandler errorHandler) &#123; this.errorHandler = errorHandler; &#125;","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"Collection第二篇-HashMap源码解析","date":"2017-02-05T06:29:57.000Z","path":"2017/02/05/Collection2/","text":"先给自己开脱一下,绝不是偷懒.看完了HashMap的源码之后颇有感悟,本想自己写一篇关于HashMap的源码的解析.但无意中发现了一篇关于HashMap源码的博客,质量非常好,何必再做无用功呢,直接转载了. 原文链接:http://www.cnblogs.com/chengxiao/p/6059914.html也可以直接点击这里查看原文.","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"Redis分布式锁的具体实现","date":"2017-02-05T05:37:06.000Z","path":"2017/02/05/redis1/","text":"前段时间看了58沈剑老师的一分钟实现分布式锁.文章中讲了互斥基本的原理,并提供了使用Redis作为锁,实现互斥的基本方案. 从想出解决方案到用代码实现方案.再到通过测试上线.这中间其实还有很长的路要走,还有很多细节要处理.幸运的是刚好我现在的项目中就是这种加锁方式.下面分享下具体的实现方式. 下面是具体代码: 个人觉得Redis实现分布式锁是最能展现Redis单进程特点的实例.在Java开发中,Spring AOP的存在让使用变的更加灵活.具体场景是这样的: 对某一个方法加切点环绕通知.不管哪次调用,哪个线程,在进入具体业务逻辑方法前,都要先通过切面的公共方法拿到锁(也就是在Redis中set一个key). 如果获取锁成功(Redis中set一个key的返回值为1),设置占用锁最长时间为10s,然后处理业务.业务处理完成后(finally中可以get到当前key),自动释放锁(del当前key). 如果获取锁失败(Redis中set一个key的返回值不为1),让线程睡眠等待释放锁. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 环绕通知@Around(&quot;aoppointcut()&quot;)public Object cacheAroundAdvice(ProceedingJoinPoint jionpoint) throws Throwable &#123; // 返回的结果 Object result = null; long nanoTime = 0; // 超时10秒超时 Integer timeout = SYSTEMFLAG.CHECK_AND_OPEN_FUNDACCO_TIME; TimeUnit unit = TimeUnit.SECONDS; // 获取参数 Object args[] = jionpoint.getArgs(); Map argMap = (Map) args[1]; // 获取key String key = &quot;AopFundAccountLockAdvice&quot; + (String) argMap.get(&quot;transActionAccountId&quot;) + (String) argMap.get(&quot;taCode&quot;); try &#123; // 获取时间判断超时 long nano = System.nanoTime(); do &#123; nanoTime = System.nanoTime(); // System.out.println(&quot;try lock key: &quot; + key); Long i = redisClientTemplate.setnx(key, Long.toString(nanoTime)); // 获得锁 if (i == 1) &#123; logger.info(&quot;成功获取锁:&quot; + key); redisClientTemplate.expire(key, 10); // 处理业务 result = jionpoint.proceed(); return result; &#125; else &#123; // 存在锁 // String desc = redisClientTemplate.get(key); // System.out.println(&quot;key: &quot; + key + &quot;locked by another business：&quot; + desc); logger.info(&quot;获取锁失败:&quot; + key + &quot; 等待获取锁时间：&quot; + SYSTEMFLAG.WAITFORLOCKTIME); Thread.sleep(SYSTEMFLAG.WAITFORLOCKTIME); &#125; if (timeout == 0) &#123; break; &#125; &#125; while ((System.nanoTime() - nano) &lt; unit.toNanos(timeout)); logger.error(&quot;锁异常:&quot; + key + &quot; 当前时间差： &quot; + String.valueOf(System.nanoTime() - nano)); throw new Exception(&quot;请求超时&quot;); &#125; catch (Exception e) &#123; logger.info(&quot;cacheAroundAdvice方法出错&quot;); throw new Exception(&quot;cacheAroundAdvice方法出错&quot;); &#125; finally &#123; String temp = redisClientTemplate.get(key); // 说明是自己的锁 logger.info(&quot;获取锁变量key：&quot; + key + &quot; value&quot; + temp); if (Long.toString(nanoTime).equals(temp)) &#123; Long boolen = redisClientTemplate.del(key); logger.info(&quot;释放锁变量key：&quot; + key + &quot; 结果：&quot; + boolen); &#125; else &#123; logger.error(&quot;异常该锁未被释放或者过期key&quot; + key); &#125; &#125;&#125;","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"Netty第一篇 入门Demo","date":"2017-01-17T14:08:16.000Z","path":"2017/01/17/netty1/","text":"年前的项目都停了,没什么开发任务了.到过年还有半个月的时间可以用来学习,棒棒的~ 为了给自己做一些技术储备,学习下NIO相关的知识.在网上找了下,Netty相关的书只有一本,评价还特别烂.各大博客网站的资料也特别零散,看起来相当费劲.所以准备自己动手,一点点学习下.以后在这里记录. 先上Demo. 据说Netty每个版本之间命名差距有些大.这里统一,都以Netty4.0版本为例. Demo包括NettyServer和NettyClient NettyServer 启动 接收数据 字符串编码器 字符串解码器 收发数据 NettyClient(与NettyServer类似) JDK版本为1.6 服务端启动成功启动后,win系统可以在dos窗口下,使用telnet localhost 3333 Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。“快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。 NettyServer Demo 启动Server的类 12345678910111213import com.netty.NettyServer;public class StartServer &#123; public static void main(String[] args) &#123; System.out.println(&quot;Netty4.0 服务开启&quot;); System.out.println(&quot;Port:3333&quot;); NettyServer ns = new NettyServer(); ns.bind(); &#125;&#125; ChildChannelHandler类 12345678910111213141516171819202122232425262728293031import io.netty.channel.ChannelInitializer;import io.netty.channel.socket.SocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;public class ChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; System.out.println(&quot;服务端与客户端成功连接&quot;); System.out.println(&quot;IP:&quot; + ch.localAddress().getHostName()); System.out.println(&quot;Port:&quot; + ch.localAddress().getPort()); // 半包处理【基于换行符】 ch.pipeline().addLast(new LineBasedFrameDecoder(1024)); // 基于指定字符串【换行符，这样功能等同于LineBasedFrameDecoder】 // e.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, false, Delimiters.lineDelimiter())); // 基于最大长度 // e.pipeline().addLast(new FixedLengthFrameDecoder(4)); // 字符串编码 ch.pipeline().addLast(new StringDecoder()); // 字符串解码 ch.pipeline().addLast(new StringEncoder()); // 在管道中添加我们自己的接收数据实现方法 ch.pipeline().addLast(new MyServerHanlder()); &#125;&#125; MyServerHanlder类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.util.Date;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;public class MyServerHanlder extends SimpleChannelInboundHandler&lt;String&gt;&#123; /* * channelAction * * channel 通道 * action 活跃的 * * 当客户端主动链接服务端的链接后，这个通道就是活跃的了。也就是客户端与服务端建立了通信通道并且可以传输数据 * */ public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; // System.out.println(&quot;Client-Server已经连接&quot;); // super.channelActive(ctx); System.out.println(ctx.channel().localAddress().toString()+&quot; channelActive&quot;); //通知您已经链接上客户端 String str = &quot;您已经开启与服务端链接&quot;+&quot; &quot;+new Date()+&quot; &quot;+ctx.channel().localAddress(); ByteBuf buf = Unpooled.buffer(str.getBytes().length); buf.writeBytes(str.getBytes()); ctx.writeAndFlush(buf); &#125; /* * channelInactive * * channel 通道 * Inactive 不活跃的 * * 当客户端主动断开服务端的链接后，这个通道就是不活跃的。也就是说客户端与服务端的关闭了通信通道并且不可以传输数据 * */ public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;Client-Server已经断开&quot;); super.channelInactive(ctx); &#125; /* * channelRead0 * * channel 通道 * Read 读 * * I msg * I 枚举类型根据你继承的SimpleChannelInboundHandler&lt;I&gt;设置来的 * * 同样你用channelRead也可以处理数据，但是作者已经提供了channelRead0，并且是抽象类 * * 简而言之就是从通道中读取数据，也就是服务端接收客户端发来的数据 * 但是这个数据在不进行解码时它是ByteBuf类型的后面例子我们在介绍 * */ protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123; //System.out.println(new Date()+&quot; 收到数据：&quot;); //System.out.println(msg); // 注意此处已经不需要手工解码了 System.out.println(new Date()+&quot; &quot;+msg); // 通知您已经链接上客户端 String str = &quot;服务端收到：&quot;+new Date()+&quot; &quot;+msg; ByteBuf buf = Unpooled.buffer(str.getBytes().length); buf.writeBytes(str.getBytes()); ctx.writeAndFlush(buf); &#125; // protected void channelRead(ChannelHandlerContext ctx, String msg) throws Exception &#123;// // 注意此处已经不需要手工解码了// System.out.println(new Date()+&quot; &quot;+msg);// // // 通知您已经链接上客户端// String str = &quot;服务端收到：&quot;+new Date()+&quot; &quot;+msg;// ByteBuf buf = Unpooled.buffer(str.getBytes().length);// buf.writeBytes(str.getBytes());// ctx.writeAndFlush(buf);// &#125; /* * channelReadComplete * * channel 通道 * Read 读取 * Complete 完成 * * 在通道读取完成后会在这个方法里通知，对应可以做刷新操作 * ctx.flush() * */ public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; super.channelReadComplete(ctx); &#125; /* * exceptionCaught * * exception 异常 * Caught 抓住 * * 抓住异常，当发生异常的时候，可以做一些相应的处理，比如打印日志、关闭链接 * */ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.exceptionCaught(ctx, cause); ctx.close(); System.out.println(&quot;异常信息：\\r\\n&quot;+cause.getMessage()); &#125;&#125; NettyServer类 1234567891011121314151617181920212223242526272829303132333435363738import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;public class NettyServer &#123; public void bind() &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workGroup); b.channel(NioServerSocketChannel.class); b.option(ChannelOption.SO_BACKLOG, 1024); b.childHandler(new ChildChannelHandler()); // 绑定端口 ChannelFuture f = b.bind(3333).sync(); // 等待服务端监听端口关闭 f.channel().closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // bossGroup.shutdownGracefully(); workGroup.shutdownGracefully(); &#125; &#125;&#125; NettyClient Demo NettyClient类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.netty4;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioSocketChannel; public class NettyClient &#123; public static void main(String[] args) &#123; try &#123; new NettyClient().connect(&quot;192.168.1.164&quot;, 3333); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void connect(String inetHost,int inetPort) throws Exception&#123; EventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(group); //group 组 b.channel(NioSocketChannel.class); //channel 通道 b.option(ChannelOption.TCP_NODELAY, true); //option 选项 b.handler(new ChildChannelHandler()); //handler 处理 //发起异步链接 ChannelFuture f = b.connect(inetHost, inetPort); //等待客户端链路关闭 f.channel().closeFuture().sync(); &#125; finally&#123; group.shutdownGracefully(); &#125; &#125;&#125; ChildChannelHandler类 12345678910111213package com.netty4;import io.netty.channel.ChannelInitializer;import io.netty.channel.socket.SocketChannel; public class ChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt;&#123; @Override protected void initChannel(SocketChannel e) throws Exception &#123; System.out.println(&quot;客户端链接到服务端&quot;); &#125;&#125;","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"Collection第一篇 ArrayList源码浅析","date":"2017-01-08T04:50:58.000Z","path":"2017/01/08/Collection1/","text":"每天写业务逻辑.代码量其实不少.不过真正总结起来,发现自己基础真心不扎实. 工作是越来越顺手,但技术还一直停留在上学时的水平. 静下来想想,自己会的东西真不多.以后会争取多整理各种常用工具类和常用框架的源码文档,在这里分享. 作为一枚Java猿,不管是在学校学习还是在公司工作,最常用的类一定是String以及Collection中的ArrayList和HashMap.这三个常用类里面,ArrayList的实现最为简单.所以先分享下自己总结的ArrayList实现方式. 下面直接上代码和注释:发现JDK版本不同,源码的设计有些差异.公司环境为JDK1.6,我的电脑环境是JDK1.7.因为在公司时间比较久,主要总结实现方式和代码逻辑.所以用1.6版本为例,两个版本差别不大.(个人觉得还是1.7版本的代码更好看) 1234567891011121314151617181920212223下面三个变量是ArrayList的全局变量.JDK1.7版本多出来一个,下面会有说明. /** * ArrayList是List的实现类,List是序列化了的.所以ArrayList也是序列化的类. * 关于Collection每个类和接口的关系以后写.这里不需要关心. * serialVersionUID就是序列化的版本号,以后写到序列化的时候再说.同样不需要关心. */ private static final long serialVersionUID = 8683452581122892189L; /** * ArrayList是基于数组实现的. elementData当然就是存放元素的数组咯. * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. */ private transient Object[] elementData; /** * 数组容量的大小. * The size of the ArrayList (the number of elements it contains). * @serial */ private int size; ArrayList共有三个构造方法,如下: ArrayList()：默认构造函数，提供初始容量为 10 的空列表。 ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表。 ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 12345678910默认无参数构造方法最常用的构造方法.new ArrayList()时,会调用下面带参数的构造方法1-&gt;public ArrayList(int initialCapacity)ArrayList初始数组容量为10. /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this(10); &#125; 12345678910111213141516171819带参数的构造方法1调用时传入int参数initialCapacity,指定初始ArrayList的大小.如果initialCapacity为负值,抛IllegalArgumentException异常.(TODO 关于异常栈的总结,以后找时间push上来) /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @exception IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); this.elementData = new Object[initialCapacity]; &#125; 1234567891011121314151617带参数的构造方法2构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列 /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&apos;s * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; ArrayList的扩容方法. ArrayList本身就是一个可变长度的数组,扩容方法可以说是核心的实现.其实就是个数组的复制过程.大一教材的内容,并不难.面试总会被问,ArrayList是怎么扩容的.就是这个东西~ 这里对方法中的modCount变量做一下特殊说明: modCount继承自AbstractList抽象类. 这个方法需要特别注意的是 modCount++这个操作,作用是用来记录对ArrayList的每一次操作,也就是说你对ArrayList的每一次操作它都会进行++,不管是add、remove等等.我们知道在对集合进行迭代的时候,不能对集合进行remove的操作,它就是通过对比这个值来判断的. 12345678910111213141516171819/** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ public void ensureCapacity(int minCapacity) &#123; modCount++;//方法中的modCount继承自AbstractList抽象类. int oldCapacity = elementData.length;//记录elementData数组的长度,也就是当前ArrayList的容量 if (minCapacity &gt; oldCapacity) &#123;// 如果传入参数minCapacity大于当前容量 Object oldData[] = elementData;// 保存当前ArrayList元素 int newCapacity = (oldCapacity * 3)/2 + 1;//用当前容量*3/2+1 计算出扩容后ArrayList的大小 经常有人说ArrayList每次扩容的大小是原来的1.5倍,就是这么来的 但并不完全正确.原因,往下看~ if (newCapacity &lt; minCapacity) // 计算出的新容量和传入参数容量的大小 两个值中较大值 newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);// 调用copy方法,扩容数组 &#125; &#125; 12345678910111213trimToSize():将此 ArrayList 实例的容量调整为列表的当前大小。/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list&apos;s current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */ public void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; //记录当前实际容量大小 if (size &lt; oldCapacity) &#123;// 判断当前实际容量与列表容量的大小,取较小值 elementData = Arrays.copyOf(elementData, size); // 按容量最小值复制数组 &#125; &#125; 123456789返回当前列表中的元素数。 /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size() &#123; return size; &#125; 123456789判断当前ArrayList是否为空. /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements. * * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements */ public boolean isEmpty() &#123; return size == 0; &#125; contains()方法调用indexof()方法,通过其返回值判断ArrayList中是否包含传入的对象.主要是indexof()方法的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253判断当前列表中是否包含传入对象. /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains * at least one element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this list is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125;返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。 /** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int indexOf(Object o) &#123; if (o == null) &#123; // 如果入参为null for (int i = 0; i &lt; size; i++) // 遍历数组 if (elementData[i]==null) // 找到value为null的索引i return i; // 返回索引 &#125; else &#123; // 如果入参不为null for (int i = 0; i &lt; size; i++) // 遍历数组 if (o.equals(elementData[i])) // 找到value为o的索引i return i; // 返回索引 &#125; return -1; // 入参对象在列表中不存在, 返回-1 &#125;返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。 /** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; // 如果入参为null for (int i = size-1; i &gt;= 0; i--) // 倒序遍历数组 if (elementData[i]==null) // 找到value为null的索引i return i; // 返回索引 &#125; else &#123; // 如果入参不为null for (int i = size-1; i &gt;= 0; i--) // 倒序遍历数组 if (o.equals(elementData[i])) // 找到value为o的索引i return i; // 返回索引 &#125; return -1; // 入参对象在列表中不存在, 返回-1 &#125; 123456789101112131415161718返回此 ArrayList 实例的浅表副本。 /** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */ public Object clone() &#123; try &#123; ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。 /** * Returns an array containing all of the elements in this list * in proper sequence (from first to last element). * * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are * maintained by this list. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this list in * proper sequence */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * Returns an array containing all of the elements in this list in proper * sequence (from first to last element); the runtime type of the returned * array is that of the specified array. If the list fits in the * specified array, it is returned therein. Otherwise, a new array is * allocated with the runtime type of the specified array and the size of * this list. * * &lt;p&gt;If the list fits in the specified array with room to spare * (i.e., the array has more elements than the list), the element in * the array immediately following the end of the collection is set to * &lt;tt&gt;null&lt;/tt&gt;. (This is useful in determining the length of the * list &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain * any null elements.) * * @param a the array into which the elements of the list are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose. * @return an array containing the elements of the list * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this list * @throws NullPointerException if the specified array is null */ public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a&apos;s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; 123456789101112131415获取当前列表中索引为i的元素. // Positional Access Operations /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; RangeCheck(index); // 校验index是否越界,具体实现方法在下面. return (E) elementData[index]; // 返回索引为i的元素 &#125; 1234567891011121314151617替换当前列表中指定位置元素 /** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E set(int index, E element) &#123; RangeCheck(index); // 校验index是否越界,具体实现方法在下面. E oldValue = (E) elementData[index]; // 保存被替换的元素 elementData[index] = element; // 替换当前位置元素 return oldValue; // 返回被替换的元素 &#125; 向列表中添加元素的方法 1234567891011121314151617181920212223242526272829303132333435add方法1:想当前列表尾插入元素 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; // 调用扩容方法,注意: 这里没有modCount变量!! ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; // 把元素插入到当前列表最后端 return true; // 返回插入成功 &#125; add方法2:向当前列表指定位置插入元素 /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) // 判断index是否合法 throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+&quot;, Size: &quot;+size); // 调用扩容方法,注意: 这里没有modCount变量!! ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); // index到列表的元素一次向后移动一个位置 elementData[index] = element; // 把元素插入到index位置 size++; // 列表容量+1 &#125; 删除方法的实现. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384remove方法1,删除列表中指定索引的元素. /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; RangeCheck(index); // 校验index是否合法 modCount++; E oldValue = (E) elementData[index]; // 保存被删除的元素 int numMoved = size - index - 1; // 计算index到列表末尾共有多少元素 if (numMoved &gt; 0) // numMoved合法,把index开始到列表末尾的所有元素一次向前移动一个位置 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后空出的位置置为空,gc启动时自动回收. elementData[--size] = null; // Let gc do its work return oldValue; //返回被删除的元素 &#125; remove方法2:根据指定元素删除. /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; // 如果元素为null for (int index = 0; index &lt; size; index++) // 遍历当前列表 if (elementData[index] == null) &#123; // 找到null元素的索引 fastRemove(index); // 删除该元素 return true; // 返回成功 &#125; &#125; else &#123; // 如果元素不为null for (int index = 0; index &lt; size; index++) // 遍历当前列表 if (o.equals(elementData[index])) &#123; // 找到当前元素的索引 fastRemove(index); // 删除该元素 return true; // 返回成功 &#125; &#125; return false; // 返回失败 &#125;fastRemove在上面remove方法中被调用. /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work &#125;clear方法,删除列表中所有元素. /** * Removes all of the elements from this list. The list will * be empty after this call returns. */ public void clear() &#123; modCount++; // Let gc do its work for (int i = 0; i &lt; size; i++) // 遍历当前列表 elementData[i] = null; // 将元素置为空 size = 0; // 返回列表长度 &#125; 添加Collection中所有元素到当前列表. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758addAll方法1: 将Collection添加到当前列表尾部 /** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection&apos;s Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); // 将Collection转成数组 int numNew = a.length; // 保存数组长度 ensureCapacity(size + numNew); // Increments modCount // 调用扩容方法 System.arraycopy(a, 0, elementData, size, numNew); // 复制数组到当前列表中 size += numNew; // 改变后数组的长度 return numNew != 0; // 返回 &#125; addAll方法2:向指定位置添加Collection /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection&apos;s iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) // 判断index是否合法 throw new IndexOutOfBoundsException( &quot;Index: &quot; + index + &quot;, Size: &quot; + size); Object[] a = c.toArray(); // 把Collection转换成数组 int numNew = a.length; // 保存数组长度 ensureCapacity(size + numNew); // Increments modCount // 调用扩容方法 int numMoved = size - index; // 计算index到最后剩余元素(需要移动元素)的个数 if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将Object[] a从index位置开始插入 System.arraycopy(a, 0, elementData, index, numNew); // 插入到末尾 size += numNew; // 改变列表长度 return numNew != 0; //返回 &#125; 需要注意,removeRange方法是protected类型的. 12345678910111213141516171819202122232425删除指定范围内的元素. /** * Removes from this list all of the elements whose index is between * &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, and &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive. * Shifts any succeeding elements to the left (reduces their index). * This call shortens the list by &lt;tt&gt;(toIndex - fromIndex)&lt;/tt&gt; elements. * (If &lt;tt&gt;toIndex==fromIndex&lt;/tt&gt;, this operation has no effect.) * * @param fromIndex index of first element to be removed * @param toIndex index after last element to be removed * @throws IndexOutOfBoundsException if fromIndex or toIndex out of * range (fromIndex &amp;lt; 0 || fromIndex &amp;gt;= size() || toIndex * &amp;gt; size() || toIndex &amp;lt; fromIndex) */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; // 计算需要移动元素的个数 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // 移动元素,将fromIndex至toIndex范围内的元素覆盖 // Let gc do its work int newSize = size - (toIndex-fromIndex); //计算新的列表长度 while (size != newSize) // 如果新的长度与原长度不相等, elementData[--size] = null; // 多出来的位置设置为null gc启动时自动回收 &#125; 123456789101112校验index是否在合法范围. /** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */ private void RangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException( &quot;Index: &quot;+index+&quot;, Size: &quot;+size); &#125; 下面关于序列化等问题的方法以后再说. 1234567891011121314151617181920212223242526272829303132333435363738394041424344 /** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123;// Write out element count, and any hidden stuffint expectedModCount = modCount;s.defaultWriteObject(); // Write out array length s.writeInt(elementData.length);// Write out all elements in the proper order.for (int i=0; i&lt;size; i++) s.writeObject(elementData[i]);if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123;// Read in size, and any hidden stuffs.defaultReadObject(); // Read in array length and allocate array int arrayLength = s.readInt(); Object[] a = elementData = new Object[arrayLength];// Read in all elements in the proper order.for (int i=0; i&lt;size; i++) a[i] = s.readObject(); &#125; 后记2017给自己的承诺已经开始兑现.这是第一篇源码浅析,还有很多细节没有写清楚.比如removeRange方法为什么会设置成Procted.最后的两个方法也没有写注释.以后都会慢慢补上. Collection的源码自己看过一些,但是总结起来发现之前还是漏掉了许多细节.争取以后慢慢都补上来. 计划是先写浅析,把常用类,常用方法具体如何实现先写清楚.然后再深入每一个细节,最后再把Collection整个继承和实现类图画出来总结一下. 工作之余完成这些东西时间确实很紧,可能也会有理解不到位出现错误的地方.随着以后理解的深入,再回来更正.这是一个漫长的过程~~~~ 这只是记录的一部分,以后争取穿插着记录一些Redis,设计模式,实际问题和解决方案. 最后是一道思考题: 123456789101112程序输出是true还是false? 为什么??我也没太仔细研究....这个需要看一下equals方法是如何重写的. List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;a&quot;); // 使用构造器创建一个包含list的列表list1 List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(list); // 使用subList生成与list相同的列表list2 List&lt;String&gt; list2 = list.subList(0, list.size()); list2.add(&quot;b&quot;); System.out.println(list.equals(list1)); System.out.println(list.equals(list2));","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"送给2017","date":"2016-12-31T16:19:25.000Z","path":"2017/01/01/20170101hello/","text":"把石头还给石头.2016真是过的浮躁. 前半年是毕业设计. 后半年是业务逻辑. 总结下来,专业能力没什么进步,也没能像以前一样静下来好好读几本书. 2017,要静下来总结每一个知识点. 记录工作中每一个问题的解决方案. 依旧要坚持每天睡觉前,看三十分钟书.(2016一整年,貌似只读了一本口水书,一本散文,一本武侠,还有半本诗集.真是惭愧) 2017,把下面的城市列在旅行计划里: 南京 郑州 成都 德令哈 2016, 看时光白白流淌. 2017, 把石头还给石头.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"纪念2016","date":"2016-12-31T15:52:46.000Z","path":"2016/12/31/20161231zj/","text":"总是盼望太多,最后如不如意,都被时间浇熄. 2016就这样吧.你好,2017~","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"处女贴~~","date":"2016-12-28T14:49:04.000Z","path":"2016/12/28/20161228/","text":"今天是搭好博客的第一天,发个帖子纪念一下.总有一些苦,要学会自己受. 要是有一天受不了了,那就找个盼头,然后让自己受得了.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]